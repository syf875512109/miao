<script type="111">
  function Stack() {
    let items = [];
    this.push = function(elements) {
      items.push(elements);
      return items.length;
    }
    this.pop = function() {
      let it = items.pop();
      return it;
    }
    this.peek = function() {
      return items[items.length - 1];
    }
    this.isEmpty = function() {
      return items.length == 0;
    }
    this.clear = function () {
      while(!isEmpty(items)) {
        items.pop();
      }
    }
    this.size = function() {
      return items.length;
    }
    this.print = function() {
      console.log(items.toString());
    }
  }
</script>


<script type="111">
  class Stack {
    constructor () {
      this.items = [];
    }

    push(element) {
      this.items.push(element);
      return this.items.length;
    }
    pop() {
      return this.items.pop();
    }
    peek() {
      return this.items[this.items.length - 1];
    }
    isEmpty() {
      return this.items.length == 0;
    }
    clear() {
      this.items = [];
    }
    size() {
      return this.items.length;
    }
    print() {
      console.log(this.items.toString());
    }
  }
</script>

<script type="111">
  let _item = Symbol();

  class Stack {
    constructor() {
      this[_item] = [];
    }
    push(element) {
      this[_item].push(element);
      return this[_item].length;
    }
    pop() {
      return this[_item].pop();
    }
    peek() {
      return this[_item][this[_item].length - 1];
    }
    isEmpty() {
      return this[_item] == 0;
    }
    clear() {
      while(!this.isEmpty()) {
        this.pop();
      }
    }
    size() {
      return this[_item].length;
    }
    print() {
      console.log(this[_item].toString());
    }
  }
</script>

<script type="111">
  
  let Stack = (function() {
  let items = new WeakMap();
  
  class Stack {
    constructor() {
      items.set(this, []);
    }

    push(element) {
      let s = items.get(this);
      s.push(element);
      return s.length;
    }
    pop() {
      let s = items.get(this);
      return s.pop();
    }
    peek() {
      let s = items.get(this);
      return s[s.length - 1];
    }
    isEmpty() {
      return items.get(this) == 0;
    }
    clear() {
      let s = items.get(this);
      while(!this.isEmpty()) {
        this.pop();
      }
    }
    size() {
      return items.get(this).length;
    }
    print() {
      console.log(items.get(this).toString());
    }
  }
  return Stack;
  })();
  function change(num, base) {
    if (base != 16) {
      return num;
    }
    switch(num) {
      case 0:
        return '0';
      case 1:
        return '1';
      case 2:
        return '2';
      case 3:
        return '3';
      case 4:
        return '4';
      case 5:
        return '5';
      case 6:
        return '6';
      case 7:
        return '7';
      case 8:
        return '8';
      case 9:
        return '9';
      case 10:
        return 'a';
      case 11:
        return 'b';
      case 12:
        return 'c';
      case 13:
        return 'd';
      case 14:
        return 'e';
      case 15:
        return 'f';
    }
  }
  function divideBy2(number, base = 2) {
    let s = new Stack();
    let binaryS = '';

    while(number) {
      s.push(String(change(number % base, base)));
      number = number / base >> 0;
    }

    while(!s.isEmpty()) {
      binaryS = binaryS + s.pop();
    }
    return binaryS;
  }
  
  function parentheseChecker(symbols) {
    let left = "([{", right = ")]}";
    let sign;
    let s = new Stack();
    let flag = true;
    let index = 0;
    let top;
    while(index < symbols.length && flag) {

      if(left.includes(symbols[index])) {
        s.push(symbols[index]);
        console.log(`left symbol - ${symbols[index]}`);
      }else {
        if (s.isEmpty()) {
          flag = false;
          console.log('Stack is empty no more symbols to pop and compare');
        }else {
          top = s.pop();
          if (!(left.indexOf(top) == right.indexOf(symbols[index]))) {
            flag = false;
            console.log(`poping sign ${top} - is not a maching compare ${symbols[index]}`);
          }else {
            console.log(`poping sign ${top} - maching compare ${symbols[index]}`);
          }
        }
      }
      index++;
    }

    if (flag && s.isEmpty()) {
      return true;
    }
    return false;
  }

  parentheseChecker('{{([][])}()}');
</script>

<script id="MaxMoney" type = "111">
  function maxMoney(nums) {
    function find(x = 0, y = 0) {
      if (x == nums.length - 1) {
        return nums[x][y];
      }else {
        return nums[x][y] + Math.max(find(x + 1, y), find(x + 1, y + 1));
      }
    }
    console.log(find());
  }
  let nums = [
    [2],
    [1, 4],
    [7, 4, 7],
    [3, 9, 8, 5],
    [3, 6, 8, 0, 7],
]
maxMoney(nums);
</script>

<script id="" type="111">
  function prN(n) {
    if (n < 10) {
      console.log(n);
      return;
    }
    console.log(n % 10);
    prN(n / 10 >> 0);
  }
  prN(12345);
</script>

<script type="print">
  function printN(n) {
    let m = +prompt();
    if (n != 1) {
      printN(n - 1);
    }
    console.log(m);
  }
  printN(5);
</script>

<script id="sort" type="sort">
  function sortArray(arr) {
    let flag;
    for(let i = 0; i < arr.length - 2; i++) {
      flag = 0;
      for (let j = 0; j < arr.length - i - 2; j++) {
        if (arr[j] > arr[j+1]) {
          arr[j] = arr[j] ^ arr[j+1];
          arr[j+1] = arr[j] ^ arr[j+1];
          arr[j] = arr[j] ^ arr[j+1];

          flag = 1;
        }
      }
      if (!flag) {
        break;
      }
    }
  }
  let array = [84, 97, 95, 27, 22, 1, 41, 48, 90, 64]
  sortArray(array);
  console.log(array);
</script>

<script type="111">
  var search = function(nums, target) {
    let left = 0;
    let right = nums.length - 1;
    let mid = (left + right) / 2 >> 0;
    while(nums[mid] != target && left < right) {
        if (nums[mid] > target) {
            max = mid - 1;
        }else {
            min = mid + 1;
        }
        mid = (left + right) / 2 >> 0;
    }
    
    if (nums[mid] == target) {
        return mid;
    }
    return -1;
  };
  let arr = [-1,0,3,5,9,12];
  debugger;
  console.log(search(arr, 9));
</script>

<script type="111">
  function aray2list(ary) {
    if (ary.length == 0) {
      return null;
    }

    let current = {
      val: ary[0],
      next: null,
    }, head = current;
    for(let i = 1; i < ary.length; i++) {
      var node = {
        value: ary[i],
        next: null,
      }
      current.next = node;
      current = node;
    }
    return head;
  }

  function arrayTolistRecusive(ary) {
    if (ary.length == 0) {
      return null;
    }

    let node = {
      value: ary[0],
      next: arrayTolistRecusive(ary.slice(1)),
    }

    return node;
  }

  function listToArray(head) {
    let current = head;
    let arr = [];

    while(current) {
      arr.push(current.value);
      current = current.next;
    }
    return arr;
  }
  function listToArrayRecusive(head, arr = []) {

    if (head == null) {
      return;
    }

    arr.push(head.value);
    listToArrayRecusive(head.next, arr);

    return arr;
  }

  function lToR(head) {
    if (head == null) {
      return [];
    }

    let currentValue = head.value;
    let arr = lToR(head.next);
    arr.unshift(currentValue);
    return arr;
  }

  function prepend(val, head) {
    let node = {};
    node.value = val;
    node.next = head;
    head = node;

    return head;
  }

  function append(val, head) {
    let current = head;
    while (head.next) {
      head = head.next;
    }
    let node = {
      value: val,
      next: null,
    }
    head.next = node;
    return current;
  }
  let l = aray2list([1, 2, 3, 4]);

  function nth(head, n) {
    if (n < 0) {
      return -1;
    }

    let p = head;
    let count = 0;
    while(p) {
      if (count == n) {
        return p.value;
      }
      count++;
      p = p.next;
    }
    return -1;
  }

  function arrayToListRecusive(arr, start = 0) {
    if (arr.length == start) {
      return null;
    }
    let head = {
      val: arr[start],
      next: arrayToListRecusive(arr, start + 1),
    }

    return head;
  }
</script>

<script type="111">
  function LinkedList() {
    let Node = function(element) {
      this.val = element;
      this.next = null;
    }

    let length = 0;
    let head = null;

    this.append = function(element) {
      let newN = new Node(element);
      
      if (head == null) {
        head = newN;
      }else {
        let present = head;
        while(present.next) {
          present = present.next;
        }
        present.next = newN;
        
      }
      length++;
      return length;
    }
    this.insert = function(position, element) {

      let newN = new Node(element);
      if (position < 0 || position >= length) {
        return false;
      }
      let present = head;
      let count = 0;
      let prev;
      if(position == 0) {
        newN.next = head;
        head = newN;
      }else {
        while(count < position) {
          prev = present;
          present = present.next;
          count++;
        }
        newN.next = prev.next;
        prev.next = newN;
      }
      length++;
      return true;
    }

    this.remove = function(element) {
      
      if (head == null) {
        return;
      }else if (head.val == element) {
        head = head.next;
        length--;
        return;
      }
      let present = head;
      let prev;
      while(present.next) {
        prev = present;
        present = present.next;
        if (present.val == element) {
          prev.next = present.next;
          length--;
          return;
        }
      }
    }

    this.indexOf = function (element) {
      let present = head;
      let count = 0;

      while(present) {
        if (present.val == element) {
          return count;
        }
        present = present.next;
        count++;
      }
      return -1;
    }

    this.removeAt = function(position) {
      if (position < 0 || position > length - 1) {
        return undefined;
      }
      if (position == 0) {
        let items = head.val;
        head = head.next;

      }
      let present = head;
      let count = 0;
      let prev, items;
      while(count < position) {
        prev = present;
        present = present.next;
        count++;
      }
      items = present.val;
      prev.next = present.next;
      length--;
      return items;
    }

    this.isEmpty = function() {
      return length == 0;
    }
    
    this.length = function() {
      return length;
    }

    this.toString = function() {
      let s = '';
      let present = head;
      while(present) {
        s = s + present.val;
        if(present.next != null) {
          s = s + '\n';
        }
        present = present.next
      }
      return s;
    }


  }
</script>

<script type="11">
function aray2list(ary) {
    if (ary.length == 0) {
      return null;
    }

    let current = {
      val: ary[0],
      next: null,
    }, head = current;
    for(let i = 1; i < ary.length; i++) {
      var node = {
        val: ary[i],
        next: null,
      }
      current.next = node;
      current = node;
    }
    return head;
  }

  var middleNode = function(head) {
    let current = head;
    let p = head;
    let count = 0;
    while (current) {
        count++;
        current = current.next;
    }
    count = (count / 2 >> 0) + 1;
    
    while(count > 1) {
        p = p.next;
        count--;
    }
    
    return p;
};

let l1 = aray2list([1, 2, 4]);
let l2 = aray2list([1, 2, 3, 4, 5]);
debugger;
middleNode(l2);

</script>

<script type="111">
  function bubblesort(array) {
    let sorted = false;
    let length = array.length;
    let temp;
    while(!sorted) {
      sorted = true;
      for(let i = 0; i < length - 1; i++) {
        if (array[i] > array[i+1]) {
          temp = array[i];
          array[i] = array[i + 1];
          array[i + 1] = temp; 

          flag = false;
        }
      }
      length--;
    }
  }

  function selectSort(array) {
    let index;
    let temp;

    for(let i = 0; i  < array.length - 1; i++) {
      index = i;
      for (j = i + 1; j < array.length; j++) {
        if (array[j] < array[index]) {
          index = j;
        }
      }

      if (index != i) {
        temp = array[index];
        array[index] = a[i];
        array[i] = temp;
      }
    }
    return array;
  }
  function hailstones(n) {
    let arr = [n];
    while (n > 1) {
      arr.push(n = (n % 2 == 0) ? n / 2 >> 0 : n * 3 + 1);
    }

    return arr;
  }
  
  function addArray(arr, n = arr.length - 1) {
    return n < 0 ? 0 : arr[n] + addArray(arr, n - 1);
  }

  // Divide and conquer
  function addArrayDivide(arr, lo, hi) {
    if (lo == hi) {
      return arr[lo];
    }
    let mid = (lo + hi) >> 1;

    return addArrayDivide(arr, lo, mid) + addArrayDivide(arr, mid + 1, hi);
  }
  function max2(arr, lo = 0, hi = arr.length) {
    let x1, x2;
    if (arr[x1 = lo] < arr[x2 = lo + 1]) {
      x1 = x1 ^ x2;
      x2 = x1 ^ x2;
      x1 = x1 ^ x2;
    }

    for(let i = lo + 2; i < hi; i++) {
      if (arr[i] > x2) {
        if (arr[x2 = i] > arr[x1]) {
          x1 = x1 ^ x2;
          x2 = x1 ^ x2;
          x1 = x1 ^ x2;
        }
      }
    }
    console.log(x1, arr[x1], x2, arr[x2])
  }

  function max2Divide(arr, lo, hi) {

    let x1, x2;

    if (lo + 1 == hi) {
      return [lo, hi - 1];
    }

    if (lo + 2 == hi) {
      return arr[lo] > arr[lo + 1] ? [lo, lo + 1] : [lo + 1, lo];
    }

    if (lo + 3 == hi) {
      if (arr[x1 = lo] < arr[x2 = lo + 1]) {
        x1 = lo + 1;
        x2 = lo;
      }
      if (arr[lo + 2] > arr[x2]) {
        if (arr[x2 = lo + 2] > arr[x1]) {
          x1 = x1 ^ x2;
          x2 = x1 ^ x2;
          x1 = x1 ^ x2;
        }
      }

      return [x1, x2];
    }


    let mid = (lo + hi) >> 1;
    let x1L, x2L, x1R, x2R;
    
    [x1L, x2L] = max2Divide(arr, lo, mid);
    [x1R, x2R] = max2Divide(arr, mid, hi);

    if (arr[x1L] > arr[x1R]) {
      x1 = x1L;
      x2 = arr[x1R] > arr[x2L] ? x1R : x2L;
    }else {
      x1 = x1R;
      x2 = arr[x1L] > arr[x2R] ? x1L : x2R;
    }
    return [x1, x2];
  }


  function longCommonSub(s1, n, s2, m, count = 0) {
    if (n < 0 || m < 0) {
      return count;
    }

    if (s1[n] == s2[m]) {
      count++;
      return longCommonSub(s1, n - 1, s2, m - 1, count);
    }

    return Math.max(longCommonSub(s1, n, s2, m - 1, count), longCommonSub(s1, n - 1, s2, m, count));
  }

  function longCommonSubTwo(s1, s2) {
    let s1Len = s1.length,
        s2Len = s2.length;

    let arr = new Array(s1Len);


    for(let i = 0; i < s1Len; i++) {
      arr[i] = [];
      for(let j = 0; j < s2Len; j++) {
        if (i == 0 || j == 0) {
          arr[i][j] = s1[i] == s2[j] ? 1 : 0;
        }else {
          arr[i][j] = s1[i] == s2[j] ? arr[i - 1][j-1] + 1 : Math.max(arr[i - 1][j], arr[i][j - 1]);
        }
      }
    }
    return arr[s1Len - 1][s2Len - 1];
  }
</script>

<script>
  function isSorted(ary) {
    if (ary.length < 2) {
      return true;
    }
    for(let i = 1; i < ary.length; i++) {
      if (ary[i] < ary[i - 1]) {
        return false;
      }
    }
    return true;
  }
  function TreeNode(val) {
    this.val = val;
    this.left = null;
    this.right = null;
  }

  function ary2Tree(ary, rootPos = 0) {
    if (ary.length == 0 || ary.length <= rootPos || ary[rootPos] == null) {
      return null;
    }

    let newNode = new TreeNode(ary[rootPos]);
    newNode.left = ary2Tree(ary, rootPos * 2 + 1);
    newNode.right = ary2Tree(ary, rootPos * 2 + 2);

    return newNode;
  }

  function tree2Ary(root, rootPos = 0, result = []) {
    if (!root) {
      result[rootPos] = null;
      return result;
    }
    result[rootPos] = root.val;
    if (root.left)
      tree2Ary(root.left, rootPos * 2 + 1, result);
    if (root.right)
      tree2Ary(root.right, rootPos * 2 + 2, result);

    return result;
  }

  function ary2TreeLc(ary) {
    if (ary.length == 0) {
      return null;
    }
    let root = new TreeNode(ary[0]);
    let help = [root];
    let flag = 1;
    let index = 0, i = 1;
    let node, current;

    while(i < ary.length) {
      current = help[index];
      if (ary[i] != null) {
        node = new TreeNode(ary[i]);
        help.push(node);
      }else {
        node = null;
      }
      i++;
      if (flag) {
        current.left = node;
        flag = 0;
      }else {
        current.right = node;
        flag = 1;
        index++;
      }
    }
    return root;
  }

  function preOrderTranverse(root, action) {
    if (root) {
      action(root.val);
      preOrderTranverse(root.left, action);
      preOrderTranverse(root.right, action);
    }
  }
  
  function inOrderTranverse(root, action = console.log) {
    if (root) {
      inOrderTranverse(root.left, action);
      action(root.val);
      inOrderTranverse(root.right, action);
    }
  }

  function postOrderTranverse(root, action) {
    if (root) {
      postOrderTranverse(root.left, action);
      postOrderTranverse(root.right, action);
      action(root.val);
    }
  }

  function tree2AryLc(root) {
    if (!root) {
      return [];
    }
    let result = [];
    let help = [root];

    let index = 0,
        current;
    result.push(root.val);

    while(index < help.length) {
      current = help[index];

      if (current.left) {
        help.push(current.left);
        result.push(current.left.val);
      }else {
        result.push(null);
      }
      
      if (current.right) {
        help.push(current.right);
        result.push(current.right.val);
      }else {
        result.push(null);
      }

      index++;
    }

    return result;
  }

  function insertIntoBST(bst, val) {
    if (!bst) {
      bst = new TreeNode(val);
      return bst;
    }
    if (val < bst.val) {
      bst.left = insertIntoBST(bst.left, val);
    }else {
      bst.right = insertIntoBST(bst.right, val);
    }

    return bst;
  }

  function bstSort(ary) {

    let bst = ary.reduce(insertIntoBST, null);
    // let bst = null;
    // for (let val of ary) {
    //   bst = insertIntoBST(bst, val);
    // }
    
    let result = [];

    inOrderTranverse(bst, item => {
      result.push(item);
    });

    return result;
  }

  function mergeSort(ary) {
    if (ary.length < 2) {
      return ary;
    }

    let mid = ary.length >> 1;
    let leftSorted = mergeSort(ary.slice(0, mid));
    let rightSorted = mergeSort(ary.slice(mid));

    let i = 0, j = 0;
    let result = []
    while (i < leftSorted.length || j < rightSorted.length) {
      if (j >= rightSorted.length || (i < leftSorted.length && leftSorted[i] < rightSorted[j])) {
        result.push(leftSorted[i++]);
      }else {
        result.push(rightSorted[j++]);
      }
    }

    return result;
  }

  function quickSort1(ary) {
    if (ary.length < 2) {
      return ary;
    }
    let mid = ary.length >> 1;

    let smallAry = [];
    let equalAry = [];
    let bigAry = [];
    for (let val of ary) {
      if (val < ary[mid]) {
        smallAry.push(val);
      }else if (val > ary[mid]) {
        bigAry.push(val);
      }else {
        equalAry.push(val);
      }
    }

    let smallSorted = quickSort1(smallAry);
    let bigSorted = quickSort1(bigAry);

    let result = [...smallSorted, ...equalAry, ...bigSorted];

    return result;
  }

  function swap(ary, i, j) {
    let temp = ary[i];
    ary[i] = ary[j];
    ary[j] = temp;
  }
  function quickSort2(ary, left = 0, right = ary.length - 1) {
    if (left >= right) {
      return;
    }
    let pivotIndex = Math.floor(Math.random() * (right - left + 1) + left);
    let pivot = ary[pivotIndex];

    swap(ary, pivotIndex, right);
    let i, j;
    for(i = left, j = left; j < right; j++) {
      if (ary[j] < pivot) {
        swap(ary, i, j);
        i++;
      }
    }

    swap(ary, i, right);

    quickSort2(ary, left, i - 1);
    quickSort2(ary, i + 1, right);

    return ary;
  }

  function quickSort3(ary, left = 0, right = ary.length - 1) {
    if (left >= right) {
      return;
    }
    let pivot = ary[left];
    let flag = 1;

    let start = left + 1, end = right;

    while(start < end) {
      if (flag) {
        while (start < end && ary[end] > pivot) {
          end--;
        }
        if (start < end) {
          ary[start] = ary[end];
          start++;
        }
      }else {
        while (start < end && ary[start] < pivot) {
          start++;
        }
        if (start < end) {
          ary[end] = ary[start];
          end--;
        }
      }
    }
    ary[start] = pivot;
    quickSort3(ary, left, start - 1);
    quickSort3(ary, start + 1, right);

    return ary;
  }

  function preOrderTranverseAry(root) {
    if (!root) {
      return [];
    }
    let result = [];
    let stack = [];
    let current = root;

    result.push(current.val);
    while (current || stack.length != 0) {
      
      if (current.right) {
        stack.push(current.right);
      }

      if (current.left) {
        result.push(current.left.val);
        current = current.left;
      }else {
        current = stack.pop();
        if (current) {
          result.push(current.val);
        }
      }
    }

    return result;
  }
</script>